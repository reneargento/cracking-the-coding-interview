The keyword volatile informs the compiler that the value of a variable it is applied to can change from the outside,
without any update done by the code. This may be done by the operating system, the hardware, or another thread.
Because the value can change unexpectedly, the compiler will therefore reload the value each time from memory.

A volatile integer can be declared by either of the following statements:
    int volatile x;
    volatile int x;

To declare a pointer to a volatile integer, the following can be done:
    volatile int * x;
    int volatile * x;

A volatile pointer to non-volatile data is rare, but can be done.
    int * volatile x;

To declare a volatile variable pointer for volatile memory (both pointer address and memory contained are volatile), the
following can be done:
    int volatile * volatile x;

Volatile variables are not optimized, which can be very useful. Imagine this function:
    int opt = 1;
    void Fn (void) {
        start:
            if (opt == 1) goto start;
            else break;
    }

At first glance, it appears to loop infinitely. The compiler may try to optimize it to:
    void Fn(void) {
        start:
            int opt = 1;
            if (true) goto start;
    }

This becomes an infinite loop. However, an external operation might write '0' to the location of variable opt, thus
breaking the loop.

To prevent the compiler from performing such optimization, it is necessary to signal that another element of the system
could change the variable. This can be done by using the volatile keyword, as shown below.
    volatile int opt = 1;
    void Fn(void) {
        start:
            if (opt == 1) goto start;
            else break;
    }

Volatile variables are also useful when multi-threaded programs have global variables and any thread can modify these
shared variables. Optimization on these variables may not be wanted.